/**
 * ----------------------------------
 * gc 算法 学习
 * 判断对象是否存活：
 * 引用计数法（jvm并没有使用，存在循环引用问题）
 * 可达性分析（gc roots）
 * -----------------------------------
 * gc roots包含的对象
 * 当前运行虚拟机栈
 * 类静态属性引用的对象
 * 类常量引用的对象
 * 本地方法栈引用的对象（native）
 * <p>
 * -----------------------------------
 * 垃圾回收算法
 * 标记清除
 * （标记已死对象（gc roots不可达），标记完成统一清除，标记和清除效率都比较低，还有产生大量碎片空间）
 * 复制算法
 * （具有两条相同大小的内存，一块空闲，gc触发后，标记存活的对象到另一块空闲的内存后统一清除，效率高，运行简单，内存始终会空闲一块）
 * （hotspot 默认分代将新生代分eden 和 survivor 8:1，gc触发后，
 *  标记（eden和一块survivor）存活的对象到另一块空闲的内存后统一清除，
 *  survivor空间不足将进入 old 担保
 *  ）
 * 标记整理
 * （复制算法在对象存活率较高的情况下，多少复制对效率有一定影响）
 * （标记整理，通常老年代算法，将存活的对象都移动到一断，清除临界另外一端的对象）
 *
 * ----------------------------------
 *
 * hotspot 垃圾收集器
 *
 * serial 单线程 【复制算法】(eden)
 * serialold 单线程 【标记整理】 (old)
 * parnew 多线程并行垃圾收集器 【复制算】法(eden)
 * parallel scavenge 吞吐量优先收集器 【复制算法】(eden)
 * parallel old 多线程 【标记整理】 (old)
 *
 * cms  并发收集，低停顿, 可与用户线程并发执行 【标记清除】(old)
 * 初始标记  stop the world
 * 并发标记
 * 重新标记  stop the world
 * 并发清除
 *  并发清除会降低系统吞吐量
 *  浮动垃圾处理
 *  碎片产生
 *
 * g1 并发并行 【标记整理】 【复制算法】  (eden, old)
 *  可预测停顿时间，建立停顿模型
 *
 */
package com.xy.jvm.gc;